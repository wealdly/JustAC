# JustAC 12.0 (Midnight) API Compatibility Analysis

Last Updated: December 2025 (Beta 3)

## Executive Summary

**JustAC should retain FULL functionality in 12.0** with minimal changes required.

Unlike rotation helpers (Hekili, WeakAuras rotation profiles) that Blizzard is targeting, JustAC:
- Displays Blizzard's own `C_AssistedCombat` suggestions (not calculating rotation)
- Does not make decisions for the player
- Functions as a visual overlay only

### Critical Updates from Blizzard (Alpha 6 / Beta 3):

1. **Player health is NOT secret** - `UnitHealth("player")` and `UnitHealthMax("player")` no longer return secrets (fixed in Alpha 6)
2. **Secondary resources NOT secret** - Combo points, runes, holy power, chi, soul shards, arcane charges
3. **Primary resources ARE secret** - Mana, energy, rage, focus (in combat)
4. **Cooldowns getting flagged** - Blizzard is flagging spells individually as non-secret
5. **New APIs available** - `SetCooldownFromExpirationTime()`, `SetAlphaFromBoolean()`, `C_StringUtil.TruncateWhenZero()`

## API Audit Results

### ‚úÖ SAFE - No Changes Required

| Module | API | Status | Notes |
|--------|-----|--------|-------|
| BlizzardAPI | `C_AssistedCombat.GetNextCastSpell()` | ‚úÖ Safe | Blizzard's own rotation helper - will remain |
| BlizzardAPI | `C_AssistedCombat.GetRotationSpells()` | ‚úÖ Safe | Core to Combat Assistant feature |
| BlizzardAPI | `C_AssistedCombat.IsAvailable()` | ‚úÖ Safe | System availability check |
| ActionBarScanner | `GetBindingKey()` | ‚úÖ Safe | Keybind lookup - not combat sensitive |
| ActionBarScanner | `HasAction()` | ‚úÖ Safe | Action bar state |
| ActionBarScanner | `GetActionBarPage()` | ‚úÖ Safe | UI state |
| UIManager | `CreateFrame()` | ‚úÖ Safe | Frame creation |
| UIManager | `LibCustomGlow` | ‚úÖ Safe | Visual effects only |
| SpellQueue | `C_Spell.GetSpellInfo()` | ‚úÖ Safe | Spell metadata (name, icon) |
| SpellQueue | `C_SpellBook.IsSpellInSpellBook()` | ‚úÖ Safe | Spell availability check |
| JustAC | `UnitHealth("player")` | ‚úÖ Usually Safe | May return secret in some instances - fallback to LowHealthFrame |
| JustAC | `UnitHealthMax("player")` | ‚úÖ Usually Safe | May return secret in some instances - fallback to LowHealthFrame |
| JustAC | `LowHealthFrame:IsShown()` | ‚úÖ Always Safe | Visual frame state - never secret, works as threshold fallback |
| JustAC | `LowHealthFrame:GetAlpha()` | ‚úÖ Always Safe | Visual property - never secret, distinguishes low vs critical |

### ‚ö†Ô∏è CONDITIONAL - May Return Secret Values

| Module | API | 12.0 Behavior | Migration Strategy |
|--------|-----|---------------|-------------------|
| UIManager | `C_Spell.GetSpellCooldown()` | Secret unless spell is flagged | Use `SetCooldownFromExpirationTime()` - accepts secrets |
| SpellQueue | `C_SpellActivationOverlay.IsSpellOverlayed()` | May return secret boolean | Use `SetAlphaFromBoolean()` for glow visibility |
| RedundancyFilter | `C_UnitAuras.GetAuraDataByIndex()` | Aura contents secret in combat | Gracefully degrade - show spell anyway |
| BlizzardAPI | `UnitAffectingCombat()` | Not secret for player | Safe to use |
| FormCache | `GetShapeshiftFormInfo()` | Should remain non-secret | Monitor for changes |

### üîÑ REQUIRES ADAPTATION

#### 1. Cooldown Display (UIManager.lua)

**Current Code:**
```lua
local cooldownInfo = C_Spell.GetSpellCooldown(spellID)
if cooldownInfo and cooldownInfo.duration > 0 then
    icon.cooldown:SetCooldown(cooldownInfo.startTime, cooldownInfo.duration)
end
```

**12.0 Migration:**
```lua
-- Option A: Use new API that accepts secrets
local cooldownInfo = C_Spell.GetSpellCooldown(spellID)
if cooldownInfo then
    icon.cooldown:SetCooldownFromExpirationTime(
        cooldownInfo.startTime + cooldownInfo.duration,
        cooldownInfo.duration
    )
end

-- Option B: Let Blizzard handle it via ActionButton cooldown template
-- (Already works this way for assisted combat buttons)
```

#### 2. Proc Glow Detection (UIManager.lua)

**Current Code:**
```lua
local hasProc = C_SpellActivationOverlay.IsSpellOverlayed and 
                C_SpellActivationOverlay.IsSpellOverlayed(spellID)
```

**12.0 Migration:**
```lua
-- If returns secret, use SetAlphaFromBoolean
local hasProc = C_SpellActivationOverlay.IsSpellOverlayed(spellID)
if issecretvalue and issecretvalue(hasProc) then
    -- Use secret-safe method
    glowFrame:SetAlphaFromBoolean(hasProc, 1.0, 0.0)
else
    -- Normal path (out of combat or API unchanged)
    if hasProc then StartProcGlow() else StopProcGlow() end
end
```

#### 3. Redundancy Filter (RedundancyFilter.lua)

**Current Code:**
```lua
for i = 1, 40 do
    local name = UnitAura("player", i, "HELPFUL")
    if name and name:find(buffName) then return true end
end
```

**12.0 Migration:**
```lua
-- Graceful degradation - if aura info is secret, skip redundancy filter
local success, name = pcall(function()
    return UnitAura("player", i, "HELPFUL")
end)
if success and name and not issecretvalue(name) then
    -- Safe to compare
end
-- If secret, the spell will show (less filtering, but still functional)
```

## Why JustAC Is Safe

From Blizzard's official statements:

> "We have no issues with addons allowing a player to perform at a competent level, but when an addon allows players to perform at a truly optimal level, it gives those players an unfair advantage. This is why our **Combat Assistant feature is non-optimal by design**."

JustAC displays the Combat Assistant output - the same data Blizzard shows on their own action buttons. We're not:
- Parsing combat log events ‚ùå
- Calculating optimal rotation ‚ùå  
- Making interrupt/cooldown decisions ‚ùå
- Simplifying enemy names ‚ùå

We ARE:
- Showing Blizzard's suggestions with hotkeys ‚úÖ
- Visual customization (glows, positioning) ‚úÖ
- Displaying cooldowns ‚úÖ

## New 12.0 APIs to Leverage

| API | Use Case |
|-----|----------|
| `issecretvalue(val)` | Check if value is secret before comparison |
| `canaccessvalue(val)` | Check if we can read the value |
| `SetAlphaFromBoolean(bool, alphaTrue, alphaFalse)` | Set visibility from secret bool |
| `SetCooldownFromExpirationTime()` | Set cooldown accepting secret values |
| `C_StringUtil.TruncateWhenZero()` | Display numbers that may be secret |

## Migration Timeline

1. **Pre-12.0 (Now)**: Document APIs, add `issecretvalue` checks where beneficial
2. **12.0 Alpha/Beta**: Test on PTR, implement migrations as needed
3. **12.0 Launch**: Ship compatible version

## Code Changes Required

### Priority 1: Add Secret Value Detection Utility

```lua
-- Add to BlizzardAPI.lua
function BlizzardAPI.IsSecretValue(value)
    return issecretvalue and issecretvalue(value) or false
end

function BlizzardAPI.CanAccessValue(value)
    return canaccessvalue and canaccessvalue(value) or true
end
```

### Priority 2: Update Cooldown Display (UIManager.lua)

Add fallback for when cooldown values are secret.

### Priority 3: Graceful Degradation for Aura Checks

Make RedundancyFilter fail-open (show spell if can't check aura).

## Health Detection for Defensives (12.0)

### What Works ‚úÖ

**LowHealthFrame Visual Overlay** (Reliable, Non-Secret)
- Blizzard's native low health warning overlay that appears on the player frame
- `LowHealthFrame:IsShown()` - Returns `true` when health drops to ~35% (configurable via CVar)
- `LowHealthFrame:GetAlpha()` - Returns higher alpha (~0.8) at critical health (~20%)
- **Why it works:** Visual frame state, not numeric health data - not affected by secrets
- **Used for:** Defensive spell priority thresholds when exact health unavailable

**UnitHealth API** (Usually Works, Sometimes Secret)
- `UnitHealth("player")` and `UnitHealthMax("player")` work most of the time
- **When secret:** In some instances or with specific encounter mechanics (unpredictable)
- **Fallback strategy:** When secrets detected, use LowHealthFrame overlay as approximation

**Current Implementation:**
```lua
function BlizzardAPI.GetPlayerHealthPercentSafe()
    local health = UnitHealth("player")
    local maxHealth = UnitHealthMax("player")
    
    -- Try exact health first (usually works)
    if health and maxHealth and maxHealth > 0 then
        if not (issecretvalue and (issecretvalue(health) or issecretvalue(maxHealth))) then
            return (health / maxHealth) * 100
        end
    end
    
    -- Fallback to visual overlay when secrets block API
    local lowHealthState = GetLowHealthState()
    if lowHealthState == "CRITICAL" then
        return 20  -- Approximate
    elseif lowHealthState == "LOW" then
        return 35  -- Approximate
    else
        return 100  -- Assume healthy
    end
end
```

### What Doesn't Work ‚ùå

**StatusBar GetValue/GetMinMaxValues** (Frequently Secret)
- `PlayerFrame.healthBar:GetValue()` and `:GetMinMaxValues()` often return secrets
- Cannot reliably compute percentage from these values
- **Reason:** These are the same underlying values as UnitHealth, subject to same secrecy

**StatusBar Texture Coordinates** (Secret-Dependent)
- `PlayerFrame.healthBar.texture:GetTexCoord()` returns secrets when health is secret
- Cannot perform arithmetic on secret coordinates to calculate fill percentage
- **Reason:** Texture coordinates derived from secret health values

**Texture Width Measurements** (Unreliable)
- Attempted to measure visual fill width: `texture:GetWidth()` or `texture:GetRight() - texture:GetLeft()`
- **Problem:** Texture size doesn't reliably reflect health percentage
- Layout/scaling issues made measurements inconsistent

**Widget Value Anchoring** (Complex, Abandoned)
- Attempted to mirror player health bar by anchoring a custom bar to the source texture
- **Problem:** Requires complex texture coordinate math that becomes secret-dependent
- Layout edge cases and scaling made this approach fragile

**Health Bar UI Clone Attempt** (v3.12 Development, Abandoned)
- Created `UIHealthBar.lua` module attempting to display numeric health percentage
- Tried multiple detection methods: GetValue, texcoords, width, anchoring
- **Conclusion:** Could not guarantee non-secret numeric percentage in all scenarios
- Module was marked abandoned and later removed from codebase

### Best Practice (Current Implementation)

Use a **tiered approach** for defensive spell detection:

1. **Try exact health** via `UnitHealth()` - works in most situations
2. **Fall back to visual overlay** (`LowHealthFrame`) when secrets block exact health
3. **Design defensive logic** to work with approximate thresholds rather than requiring exact percentages

**Priority System (Does Not Require Exact Health):**
- **Procs** ‚Üí Always show at any health (Victory Rush, Regrowth proc, etc.)
- **Low (~35%)** ‚Üí Show big self-heals
- **Critical (~20%)** ‚Üí Show major cooldowns > potions > heals

This approach works because:
- Proc detection is event-driven (not dependent on health)
- Threshold-based priorities tolerate approximate health ranges
- Visual overlay state is always accessible (never secret)

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| C_AssistedCombat restricted | Very Low | Critical | Would require complete redesign - but this is Blizzard's own feature |
| Cooldown display breaks | Low | Low | Use new `SetCooldownFromExpirationTime()` API - accepts secrets |
| Proc detection breaks | Medium | Low | Use `SetAlphaFromBoolean()` for glow visibility |
| Aura checks break | High | Very Low | Skip redundancy filter - spells just show (fail-open) |
| Hotkey detection breaks | Very Low | High | GetBindingKey is not combat-sensitive |
| Player health secret | **Medium** | Medium | LowHealthFrame overlay provides fallback thresholds |
| Defensive suggestions break | Low | Medium | Falls back to approximate thresholds when secrets block exact health |

## JustAC Feature Availability Matrix

| Feature | 12.0 Status | Notes |
|---------|-------------|-------|
| Core spell suggestions | ‚úÖ Works | C_AssistedCombat is Blizzard's feature |
| Hotkey display | ‚úÖ Works | Binding APIs not combat-sensitive |
| Defensive suggestions | ‚úÖ Works | UnitHealth usually safe; LowHealthFrame fallback for thresholds |
| Health percentage display | ‚ùå Not Reliable | Cannot guarantee non-secret numeric percentage in all scenarios |
| Redundancy filter | ‚ö†Ô∏è Degraded | Aura contents secret - will fail-open |
| Proc glow detection | ‚ö†Ô∏è Degraded | Use SetAlphaFromBoolean if secret |
| Cooldown display | ‚ö†Ô∏è Partial | Use SetCooldownFromExpirationTime |
| Form detection | ‚úÖ Works | GetShapeshiftFormInfo not restricted |
| Health text on icons | ‚úÖ Works | UnitHealth("player") confirmed safe |

## Implementation Status

### ‚úÖ Already Implemented

- `BlizzardAPI.IsSecretValue()` - Check if value is secret
- `BlizzardAPI.IsDefensivesFeatureAvailable()` - Test health API access
- `BlizzardAPI.IsRedundancyFilterAvailable()` - Test aura API access
- `BlizzardAPI.RefreshFeatureAvailability()` - Force re-check on login
- RedundancyFilter fail-open behavior
- `/jac modules` shows feature availability status
- **NEW**: `BlizzardAPI.IsSpellUsable()` - Falls back to `C_ActionBar.IsUsableAction()` when secrets detected
- **NEW**: `ActionBarScanner.GetSlotForSpell()` - Gets action bar slot for spell (for action bar fallback)
- **NEW**: `BlizzardAPI.GetPlayerHealthPercentSafe()` - Returns exact health when available, falls back to LowHealthFrame thresholds
- **NEW**: `BlizzardAPI.GetLowHealthState()` - Returns "NONE", "LOW" (~35%), or "CRITICAL" (~20%) based on visual overlay

### Action Bar Usability Fallback (12.0)

When `C_Spell.IsSpellUsable()` returns secret values for `isUsable` or `notEnoughResources`, we now:

1. Look up the action bar slot for the spell via `ActionBarScanner.GetSlotForSpell()`
2. Call `C_ActionBar.IsUsableAction(slot)` to check the visual icon state
3. If action bar state is non-secret (it's visible state, not combat data), use that result
4. If no slot found or action bar also secret, fail-open (assume usable)

This allows the blue tint for "not enough resources" to work even when the spell usability API is secret, because the action bar icon desaturation is a **visual property** that Blizzard allows addons to read.

### üî≤ TODO for 12.0 Launch

1. Update UIManager to use `SetCooldownFromExpirationTime()` for cooldown display
2. Update proc detection to use `SetAlphaFromBoolean()` when secret
3. Add testing CVars support: `secretAurasForced`, `secretCooldownsForced`
4. Test in Midnight beta with test encounter in MOTHERLODE!!

## Conclusion

JustAC is well-positioned for 12.0 because:

1. **We consume Blizzard's Combat Assistant** - they won't break their own feature
2. **We don't do rotation calculation** - just display what Blizzard tells us
3. **Visual APIs remain accessible** - addons can still customize look/feel
4. **Hotkey lookups are safe** - binding information isn't combat-sensitive
5. **Player health is confirmed safe** - UnitHealth("player") NOT secret (Alpha 6+)
6. **Action bar icon state is visible** - desaturation/color reflects usability

The worst-case scenario is reduced functionality in the redundancy filter and proc detection - but the core functionality (showing suggestions with hotkeys) will work.

## References

- [Patch 12.0.0/Planned API changes](https://warcraft.wiki.gg/wiki/Patch_12.0.0/Planned_API_changes) - Blizzard's weekly updates
- [Patch 12.0.0/API changes](https://warcraft.wiki.gg/wiki/Patch_12.0.0/API_changes) - Technical API documentation
- [Midnight Public Beta Update (Nov 13)](https://discord.com/channels/327414731654692866/1438595756083904614) - Philosophy explanation
- [Beta 6 Changes (Jan 12)](https://discord.com/channels/327414731654692866/1460387750480969840) - Latest API updates
